<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   <meta name="GENERATOR" content="Mozilla/4.72 [en] (Win98; I) [Netscape]">
   <title>Shell</title>
</head>
<body>
<center>Лабораторная работа</center>
<br><center>по дисциплине "Операционные системы и среды"</center>
<p>
<p><center><b>ИНТЕРПРЕТАТОРЫ КОМАНДНОЙ СТРОКИ ОС LINUX</b></center>
<p>
<p>Цели работы:
<p>1) Изучение основных команд пользовательского интерфейса
<p>2) Изучение цикла подготовки и исполнения программ
<p>3) Изучение команд и утилит обработки текстов
<p>
 
<p><center><b>Программа работы</b></center>
<p>
<p><b><i>I. Подготовка к работе.</i></b>
<p>
<p>1.&nbsp; Получить у преподавателя входное имя (account) и пароль (password)
для регистрации пользователя в ОС Linux.
<p>После успешной загрузки операционной системы появляется окно регистрации
пользователя. В нём необходимо заполнить строки&nbsp; регистрационного
имени (login), и пароля (passwd). Символы пароля при вводе на экране не
отображаются или отображаются звёздочками.
<p>После успешного ввода регистрационного имени и пароля производится завершение
загрузки ОС (конфигурация графической оболочки). Дальнейшая работа с ОС
осуществляется путём вызова необходимых программ из Панели задач либо из
Главного меню.
<p>2.&nbsp; Для выполнения лабораторных работ рекомендуется использовать
режим терминала. В этом режиме обработку командных строк осуществляет интерпретатор командной строки - 
shell.
<p>3. Создать файл отчета.
<br>Создать файл можно переназначив вывод с экрана в файл.
<p>$ >myfile.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (образуется пустой
файл с именем myfile.txt).
<p>В процессе работы Вам следует копировать в этот файл те фрагменты (сообщения,
результаты выполнения команд, т.д.), которые Вы планируете представить
в отчете.
<p>Просмотр и редактирование файла отчета (равно как и любого другого текстового
файла) можно производить в текстовых редакторах (как встроенных в графическую
оболочку, так и вызываемых непосредственно из shell).

<p><b><i>II. Основы работы c командным интерфейсом.</i></b>
<p>
<p>Единицей действия является команда. Значением команды служит код завершения.
<p>Синтаксис команд в большинстве случаев имеет вид:
<p>имя_команды&nbsp; [флаги]&nbsp; [аргументы]&nbsp; .
<p>Команда передается системе только после нажатия &lt;Enter>, т.о. при
неправильном наборе можно затереть один&nbsp; или&nbsp; несколько&nbsp;
символов с помощью клавиши DEL , или всю строку -- &lt;^U>.

<p>1. Введите следующие информационные команды для получения
полезных сведений об ОС и текущем сеансе:
<p>date -- вывод текущей даты;
<br>who&nbsp; -- кто находится в системе;
<br>who am i&nbsp; ;
<br>tty&nbsp; -- полное имя файла-терминала;
<br>logname -- входное имя;
<br>uname&nbsp; --&nbsp; имя&nbsp; UNIX-системы&nbsp; ("имя компьютера")
<p>Прокомментируйте ответы системы.

<p>2. Введите команду:
<p>sleep 5&nbsp; ( "спать" 5 секунд ).
<p>Через 5 секунд появиться очередное приглашение ' $'. Введите затем:
<p>sleep 10000
<p>Через какое время вновь должно появиться приглашение ? Пошлите команде
sleep сигнал прерывания (SIGINT --&nbsp; INTERRUPT) , введя символ &lt;^C>.
Как отреагировала система?

<p>3. Справочное руководство
<p>Используйте команду ' man '&nbsp; для&nbsp; получения справочной информации&nbsp;
о различных командах системы ( 'man date' , 'man who' , ' man tty ' и т.д.&nbsp;
). 
<p>Выявите общие правила
построения справочников в ОС Linux (разделы и т.п.). 

<p>4. Работа с файлами
<p>Для навигации в файловой системе ОС Linux служат файловые менеджеры.
Файловым менеджером, аналогичным Norton Commander (для MS-DOS, Win9x), является программа
Midnight Commander. Её вызов производится командой mc.
<br>Для&nbsp; создания&nbsp; файлов&nbsp; используйте текстовые редакторы, встроенные в графическую оболочку системы.
<p>a) Для получение информации о файлах из командной строки служит команда ls
<br>Введя команду ls, получим (здесь и далее приведены примерные реакции
системы):
<p>$ ls
<br>junk
<br>temp
<br>$
<p>- команда&nbsp; перечисляет имена существующих в вашем каталоге файлов.
<br>Используя команду&nbsp; ls&nbsp; с ключом&nbsp; -l, получим:
<p>$ ls -l
<br>total 2
<br>rw-r--r--&nbsp;&nbsp; 1 buc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; people&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
19 Aug 30 17:28 junk
<br>rw-r--r--&nbsp;&nbsp; 1 buc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; people&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
32 Aug 30 17:28 temp
<br>$
<br>Прокомментируйте результат.&nbsp; Что&nbsp; будет,&nbsp; если&nbsp;
ввести&nbsp; 'ls junk' ? 'ls junk temp' ?
<p>b) Вывод содержимого файлов. Выведите содержимое&nbsp; имеющихся&nbsp;
у вас файлов с помощью команды cat :
<p>$ cat junk
<br>$ cat temp
<br>$ cat junk temp
<p>Что происходит, если cat получает несколько аргументов ?
<p>c) Операции с файлами
<br>Переименование файла осуществляется пересылкой его от одного имени
к другому (mv -- move):
<p>$ mv junk aaa
<br>$ ls
<br>aaa
<br>temp
<br>$ cat junk
<br>cat: cannot open junk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(junk`а уже нет)
<br>$
<p>Копирование файлов осуществляется с помощью команды cp:
<p>$ cp aaa bbb
<br>$ ls
<br>aaa
<br>bbb
<br>temp
<br>$
<p>Удаляет файлы команда rm :
<p>$ rm temp junk
<br>rm: junk non-existent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (файла
junk на существует)
<br>$
<p>$ rm aaa bbb
<br>$ ls
<br>$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(никаких файлов нет)
<p>Поинтересуйтесь в справочном руководстве работой&nbsp; mv&nbsp; , cp
и rm .
<p>5. Работа с каталогами.
<p>Определите полное имя вашего текущего&nbsp; каталога с помощью&nbsp;
команды&nbsp; pwd . Создайте произвольный файл&nbsp; prog.c. Как по-вашему
должно выглядеть полное имя файла prog.c ?
<p>Введите ' ls &lt;имя_вашего_каталога> '&nbsp; .&nbsp; Как&nbsp; выводимые
данные соотносятся с выводом "простой" команды 'ls'?&nbsp; Введите&nbsp;
 ,&nbsp; 'ls / ' , 'ls -l /' . Что можно сказать о
содержимом каталога /bin ?
<p>Перейдите в вышележащий каталог с помощью команды cd :
<p>cd ..
<p>Определите его полное имя и содержимое.
<br>Поднимитесь еще "выше". Определите полное имя.
<br>Поднимитесь еще "выше". Куда вы попали? Куда будете попадать, если
продолжать это до бесконечности?
<p>С помощью команды ls с ключами 'l' и 'd' ('ls -ld') определите владельцев
каталогов / , /bin , и вашего домашнего каталога. 
Можете ли&nbsp; вы изменить содержимое каталогов / или /bin?
<p>Вернитесь в свой домашний каталог с помощью команды cd без аргументов.
Проверьте результат.
<p>Создайте в своем каталоге подкаталог командой mkdir :
<p>mkdir&nbsp; &lt;имя_каталога>
<p>Перейдите в него ( cd &lt;имя_каталога> ). Нужно ли указывать&nbsp; полное маршрутное
имя для перехода? В каком случае это было бы необходимо ?
<br>Скопируйте в новый каталог какой-либо файл из вышележащего (исходного)
каталога:
<p>cp ../prog.c&nbsp; .
<p>( '.' -- синоним текущего каталога, '..' -- вышележащего. В случае,
если 2-й аргумент команды cp -- каталог, файл копируется в него под тем
же именем. )
<br>Вернитесь в вышележащий каталог. (Сколькими способами в данном случае
это можно сделать? ). Выполните команду ls.
<br>Попробуйте&nbsp; удалить&nbsp; свой&nbsp; подкаталог с помощью команды
rmdir&nbsp; .&nbsp; Каков&nbsp; результат? Удалите файлы из этого каталога
( rm &lt;имя>/prog.c ) и повторите попытку его&nbsp; удаления.&nbsp; Что
получилось? (' ls ').


<p>6. Процессы ОС Linux
<p>Введите команду ps -- информация о процессах, запущенных&nbsp; с вашего
терминала. Более полную информацию о процессах в системе предоставляет команда ps с ключом -A. 
Прокомментируйте полученную информацию, для чего обратитесь
к справочному руководству.


<p><b><i>III. Изучение цикла подготовки и исполнения программ в ОС Linux.</i></b>

<p>
<p>Язык С тесно связан с ОС UNIX,&nbsp; т.к. первоначально был разработан
именно для реализации ядра ОС. В первую очередь, он удобен для задач,&nbsp;
использующих системные вызовы, например, для управления памятью&nbsp; и
физическими устройствами, организации связи между процессами и т.д. Однако,
С успешно применяется и для реализации программ,&nbsp; не требующих такого
непосредственного взаимодействия с ОС.&nbsp; Цикл выполнения программ в
UNIX аналогична большинству других ОС.
<br>Файлы с исходными текстами С-программ должны
иметь расширение '.с'. Команда вызова компилятора имеет следующий вид:
<p>сс &lt;имя_программы>
<p>При успешном исходе компиляции после нее будет выполнено&nbsp; редактирование
связей и сгенерирован выполняемый файл 'a.out'.&nbsp; Для управления процессом
компиляции и редактирования связей команда 'сс' имеет несколько опций, в том числе:
<br>-с - подавляется фаза редактирования&nbsp; связей. Генерируется объектный
файл, который может быть использован для редактирования связей с помощью
команды 'сс' без опции -с;
<br>- о &lt;вых.файл> - выполняемый файл, полученный после редактирования
связей, будет иметь имя &lt;вых.файл>, а не 'a.out'.
<br>Остальные опции, используемые командой 'сс', описаны в справочном руководстве.
<br>Редактор связей объединяет несколько объектных файлов в один, выполняет
настройку ссылок, включает процедуры инициализации и генерирует таблицу
имен,&nbsp; используемую отладчиком. Разумеется , можно выполнять редактирование
связей и в случае единственного объектного файла. Результат редактирования
по умолчанию помещается в файл 'a.out'. Команда 'ld' вызывает редактор связей
непосредственно. Однако обычно эта команда не используется. Как правило,
применяется команда запуска системы компиляции того или иного языка (например, 'сс', 'gcc', 'g++'), 
которая сама вызывает редактор связей.
<p>Информация или управляющие параметры могут&nbsp; передаваться в С-программу
как&nbsp; аргументы командной строки при запуске программы. При этом указанные
в командной строке&nbsp; аргументы&nbsp; передаются функции main() через
два ее параметра,&nbsp; первый из которых содержит количество аргументов,
а второй является массивом указателей на цепочки символов, содержащие передаваемую
в качестве аргументов информацию (выполнение любой С-программы начинается
с функции main()).&nbsp; Обычно параметры функции main() имеют имена argc
и argv, хотя это и не обязательно.&nbsp; Argc - целое число, равное количеству
передаваемых&nbsp; аргументов.&nbsp; Это&nbsp; число всегда больше или
равно 1, поскольку сама команда считывается первым аргументом, и arg[0]
является&nbsp; указателем на цепочку символов,&nbsp; представляющую команду.
<p>
<p>С помощью любого текстового редактора создайте
файл prog.c, содержащий следующий исходный текст С-программы:
<p>&nbsp;#include &lt;stdio.h>
<br>main ()
<br>{
<br>printf ("Hello, everybody ! ");
<br>}
<p>Создайте объектный&nbsp; файл.&nbsp; Определите, какое ему присвоено
имя. Соберите исполняемый файл. Проанализируйте результат. Получите исполняемый&nbsp;
файл&nbsp; с именем hello из файла с исходным текстом. Проверьте работоспособность
полученных исполняемых&nbsp; файлов. Переназначьте вывод программы в файл
res. Проверьте результат.
<p>Для изучения&nbsp; передачи&nbsp; информации&nbsp; в&nbsp; С-программы
создайте файл с именем my_open.с, содержащий исходный&nbsp; текст&nbsp;
следующей С-программы.
<p>&nbsp;#include &lt;stdio.h>
<br>main ( argc, argv )
<br>int argc;
<br>char *argv [];
<br>{
<br>if (argc > 1) {
<br>&nbsp;&nbsp; if (fopen(argv[1],"r") == NULL) {
<br>printf("%s: неудача при попытке открыть файл %s",argv[0],argv[1]);
<br>&nbsp; else
<br>printf("%s: файл %s открыт",argv[0],argv[1]);
<br>}
<br>else
<br>&nbsp;&nbsp;&nbsp;&nbsp; printf("открываемый файл не указан");
<br>}
<p>Создайте исполняемый файл. Исполните программу, передавая в качестве
аргумента имя реально существующего файла&nbsp; (предварительно создайте&nbsp;
его),&nbsp; имя не существующего файла и не указывая никакого аргумента.
Проанализируйте результаты.
<p>В ОС UNIX есть возможность направлять выходной поток&nbsp; одной программы
на вход другой программы - организация конвейера. Откорректируйте первую
программу, создав файл file_name.c, таким образом, чтобы на печать выводилось
имя файла (существующего или не существующего).&nbsp; Получите исполняемую
программу с именем file_name. Попытайтесь организовать конвейер из двух
созданных исполняемых программ командой:
<p>file_name||my_open
<p>а также другой командой:
<p>file_name|my_open
<p>Проанализировав полученные результаты, уясните различие двух использованных типов конвейеров.
Если не удалось выполнить конвейер команд, исправьте тексты С-программ требуемым образом. 
В отчете представьте пояснения выполненным Вами действиям.



<p><b><i>IV. Изучение команд и утилит обработки текстов.</i></b>
<p>
<p>Существует большое&nbsp; число&nbsp; команд&nbsp; UNIX,&nbsp; которые&nbsp;
читают входной поток,&nbsp; выполняют&nbsp; простые операции над ним и
записывают результат в выходной поток.&nbsp; Такие программы называются
фильтрами. Многие команды могут быть фильтрами, поскольку обычно в случае
незадания файла-аргумента читается стандартный ввод.&nbsp; Важной особенностью
фильтров&nbsp; является то,&nbsp; что они никогда не изменяют исходных
файлов,&nbsp; а лишь выводят на стандартный вывод обработанную информацию.&nbsp;
Стандартный&nbsp; вывод&nbsp; также можно переназначить в файл.
<p>1. G r e p - поиск по шаблону, заданному регулярным выражением
<p>Команда grep имеет следующий синтаксис:
<p>grep [опции] &lt;шаблон> [файл ...]
<p>Команда grep сопоставляет строки исходных файлов с шаблоном, заданным
ограниченным регулярным выражением. Если файлы не указаны, используется
стандартный ввод. Обычно каждая успешно сопоставленная строка копируется
на стандартный вывод; если исходных файлов несколько,&nbsp; перед найденной
строкой&nbsp; выдается&nbsp; имя файла. В&nbsp; качестве шаблонов воспринимаются
ограниченные регулярные выражения - см. справочное руководство по команде 'grep'.
<br>Для экранирования символов $,*,[],^,!,() и \ от интерпретации shell
проще всего заключать ограниченное регулярное выражение в одинарные кавычки.
<br>Перечень опций команды также рекомендуется изучить, пользуясь справочным руководством.
<p>Выведите только те строки из вывода ls -l /tmp, которые:
<br>1) соответствуют каталогам;
<br>2) соответствуют выполняемым для всех файлам;
<br>3) принадлежат пользователь root;
<br>4) не принадлежат пользователю root.
<p>2. C u t&nbsp; - выборка отдельных полей из строк файла
<p>Команда cut имеет следующий синтаксис:
<p>&nbsp;cut -cсписок [файл ...]
<p>cut -fсписок [-dсимвол][-s][файл ...]
<p>Команда cut используется для выборки колонок из таблицы или полей из
каждой строки файла. Поля, специфицированные списком, могут быть фиксированной
(опция -с) или переменной длины&nbsp; (опция -f). В случае переменной длины
поля границей поля является символ-разделитель (опция -d). По умолчанию
разделителем&nbsp; является символ табуляции. Значения опций следует уточнить
по справочному руководству.
<p>Определите с использованием команды cut:
<br>1) номера запущенных Вами процессов;
<br>2) идентификаторы пользователей,&nbsp; имеющих&nbsp; x-терминалы на
Вашей рабочей станции;
<br>3) Ваше входное имя в системе.
<p>3. T r&nbsp; -&nbsp; преобразователь символов
<p>Команда tr имеет следующий синтаксис:
<p>&nbsp;tr [опции] цепочка1 цепочка2
<p>Команда tr копирует стандартный ввод на стандартный вывод с заменой
либо удалением выбранных символов.&nbsp; Символы, найденные в цепочке1,&nbsp;
заменяются&nbsp; на&nbsp; соответствующие&nbsp; символы из цепочки2. Чтобы
помещать в цепочки отрезки&nbsp; алфавита,&nbsp; можно&nbsp; использовать
сокращение: [c1-c2] -- цепочка символов, коды ASCII которых принадлежат
отрезку от кода символа с1 до с2.
<p>Выведите информацию о ваших файлах прописными буквами.
<p>4. S o r t - сортировка и / или слияние файлов
<p>Команда sort имеет следующий синтаксис:
<p>&nbsp;sort [опции] [файл...]
<p>Команда sort сортирует строки,&nbsp; входящие во все исходные файлы,
и выдает результат на стандартный вывод. При упорядочении используется
один или несколько ключей сортировки, выделяемых из каждой вводимой строки.
По умолчанию ключ сортировки один - вся строка, а порядок является&nbsp;
лексикографическим,&nbsp; соответствующим принятой кодировке символов.
Опции, изменяющие стандартный порядок работы, изучите по справочному руководству.
<p>Отсортируйте файлы в вашем каталоге (ls -l):
<br>1) в алфавитном порядке,
<br>2) в порядке увеличения размеров файлов,
<br>3) в порядке уменьшения размеров файлов.
<p>5. U n i q&nbsp; -&nbsp; выдача информации о повторяющихся строках
файла
<p>Команда uniq имеет следующий синтаксис:
<p>&nbsp;uniq [опции] [исходный файл [выходной файл]]
<p>Команда uniq&nbsp; читает&nbsp; исходный&nbsp; файл&nbsp; и сравнивает
соседние строки. В обычном режиме вторая и последующие копии повторяющейся
строки исключаются;&nbsp; остаток поступает в выходной файл, который не
должен совпадать с исходным. Для того, чтобы повторяющиеся строки были
соседними, файл надо отсортировать.
<p>Выведите повторяющиеся размеры файлов из каталога /usr/bin. Для этого
из вывода ls -l с помощью cut оставьте только размеры, отсортируйте полученный&nbsp;
поток&nbsp; и&nbsp; из результата выделите только повторения.
<p>6. C m p&nbsp; - сравнение двух файлов
<p>Команда cmp имеет следующий синтаксис:
<p>&nbsp;cmp [опции] файл1 файл2
<p>Команда cmp производит побайтное сравнение и прекращает работу при первом
несовпадении.
<p>Сравните файлы исходных текстов и объектные файлы созданных С-программ.
<p>7. D i f f&nbsp; -&nbsp; выявление различий между файлами
<p>Команда diff имеет следующий синтаксис:
<p>diff [опции] файл1 файл2
<p>Команда diff выдает на стандартный вывод только те строки файлов, которые
нужно изменить, чтобы привести файлы в соответствие друг с другом.
<p>Сравните prog.c и my_open.c с помощью diff:
<p>diff -e prog.c my_open.c > eqv
<p>Проанализируйте содержимое eqv.


<p><b><i>V. Оформление отчета.</i></b>
<p>Отредактировать и оформить отчет по лабораторной работе.
<p>

<p><b><i>VI. Завершение работы.</i></b>
<p>Для завершения работы необходимо выполнить стандартную процедуру завершения
пользовательского сеанса.

</body>
</html>
